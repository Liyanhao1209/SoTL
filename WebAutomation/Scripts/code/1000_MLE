import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.StreamTokenizer;import java.util.ArrayDeque;import java.util.Arrays;/*15 5S-###-----##---E#------## */public class Main {    static int[][] directions = new int[][]{            {-1,0},            {0,1},            {1,0},            {0,-1}    };    public static void main(String[] args) throws IOException {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        int n = Integer.parseInt(br.readLine());        for (int i = 0; i < n; i++) {            solve(br);        }    }    private static void solve(BufferedReader br) throws IOException {        String[] nm = br.readLine().split(" ");        int n = Integer.parseInt(nm[0]);        int m = Integer.parseInt(nm[1]);        int[][] maze = new int[n][m];        for (int i = 0; i < n; i++) {            Arrays.fill(maze[i],Integer.MAX_VALUE);        }        int ex=0,ey=0;        int sx=0,sy=0;        for (int i = 0; i < n; i++) {            char[] ch = br.readLine().toCharArray();            for (int j = 0; j < m; j++) {                char c = ch[j];                if(c=='S'){                    maze[i][j] = 0;                    sx = i;                    sy = j;                }else if(c=='#'){                    maze[i][j] = -1;                }else if(c=='E'){                    ex = i;                    ey = j;                }            }        }        boolean[][] vis = new boolean[n][m];        for (int i = 0; i < n; i++) {            Arrays.fill(vis[i],false);        }        ArrayDeque<int[]> q = new ArrayDeque<>();        q.offerLast(new int[]{sx,sy});        int x,y,nx,ny;        while(!q.isEmpty()){            int[] cors = q.pollFirst();            x = cors[0];            y = cors[1];            int dis = maze[x][y];            if(x==ex && y==ey){                System.out.println(dis);                return;            }            for (int[] direction : directions) {                nx = x+direction[0];                ny = y+direction[1];                if(checkValid(nx,ny,n,m) && maze[nx][ny]!=-1 && !vis[nx][ny]){                    maze[nx][ny] = dis+1;                    q.offerLast(new int[]{nx,ny});                }            }        }        System.out.println(-1);    }    private static boolean checkValid(int x,int y,int n,int m){        return x>=0 && x<n && y>=0 && y<m;    }}