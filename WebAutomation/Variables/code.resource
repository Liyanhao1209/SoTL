*** Variables ***
${1000_CE}        sout(char16_t 1111)
${1000_MLE}       import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.StreamTokenizer;import java.util.ArrayDeque;import java.util.Arrays;/*15 5S-###-----##---E#------## */public class Main { \ \ \ static int[][] directions = new int[][]{ \ \ \ \ \ \ \ \ \ \ \ {-1,0}, \ \ \ \ \ \ \ \ \ \ \ {0,1}, \ \ \ \ \ \ \ \ \ \ \ {1,0}, \ \ \ \ \ \ \ \ \ \ \ {0,-1} \ \ \ }; \ \ \ public static void main(String[] args) throws IOException { \ \ \ \ \ \ \ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \ \ \ \ \ \ \ int n = Integer.parseInt(br.readLine()); \ \ \ \ \ \ \ for (int i = 0; i < n; i++) { \ \ \ \ \ \ \ \ \ \ \ solve(br); \ \ \ \ \ \ \ } \ \ \ } \ \ \ private static void solve(BufferedReader br) throws IOException { \ \ \ \ \ \ \ String[] nm = br.readLine().split(" "); \ \ \ \ \ \ \ int n = Integer.parseInt(nm[0]); \ \ \ \ \ \ \ int m = Integer.parseInt(nm[1]); \ \ \ \ \ \ \ int[][] maze = new int[n][m]; \ \ \ \ \ \ \ for (int i = 0; i < n; i++) { \ \ \ \ \ \ \ \ \ \ \ Arrays.fill(maze[i],Integer.MAX_VALUE); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ int ex=0,ey=0; \ \ \ \ \ \ \ int sx=0,sy=0; \ \ \ \ \ \ \ for (int i = 0; i < n; i++) { \ \ \ \ \ \ \ \ \ \ \ char[] ch = br.readLine().toCharArray(); \ \ \ \ \ \ \ \ \ \ \ for (int j = 0; j < m; j++) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ char c = ch[j]; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(c=='S'){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ maze[i][j] = 0; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sx = i; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sy = j; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }else if(c=='#'){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ maze[i][j] = -1; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }else if(c=='E'){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ex = i; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ey = j; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ } \ \ \ \ \ \ \ boolean[][] vis = new boolean[n][m]; \ \ \ \ \ \ \ for (int i = 0; i < n; i++) { \ \ \ \ \ \ \ \ \ \ \ Arrays.fill(vis[i],false); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ ArrayDeque<int[]> q = new ArrayDeque<>(); \ \ \ \ \ \ \ q.offerLast(new int[]{sx,sy}); \ \ \ \ \ \ \ int x,y,nx,ny; \ \ \ \ \ \ \ while(!q.isEmpty()){ \ \ \ \ \ \ \ \ \ \ \ int[] cors = q.pollFirst(); \ \ \ \ \ \ \ \ \ \ \ x = cors[0]; \ \ \ \ \ \ \ \ \ \ \ y = cors[1]; \ \ \ \ \ \ \ \ \ \ \ int dis = maze[x][y]; \ \ \ \ \ \ \ \ \ \ \ if(x==ex && y==ey){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ System.out.println(dis); \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return; \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ for (int[] direction : directions) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ nx = x+direction[0]; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ny = y+direction[1]; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(checkValid(nx,ny,n,m) && maze[nx][ny]!=-1 && !vis[nx][ny]){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ maze[nx][ny] = dis+1; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ q.offerLast(new int[]{nx,ny}); \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ } \ \ \ \ \ \ \ System.out.println(-1); \ \ \ } \ \ \ private static boolean checkValid(int x,int y,int n,int m){ \ \ \ \ \ \ \ return x>=0 && x<n && y>=0 && y<m; \ \ \ }}
${1003_TLE}       for i in range(pow(2,64)): \ \ \ j = i+1
${1004_RE}        import osnum_files = pow(2,64)current_dir = os.getcwd()for i in range(num_files): \ \ \ filename = f"hack_file_{i}.txt" \ \ \ filepath = os.path.join(current_dir, filename) \ \ \ with open(filepath, "w") as f: \ \ \ \ \ \ \ f.write(f"This is hack_file {i}")print(f"Generated {num_files} files in {current_dir}")
${1005_WA}        public class Main{ \ \ \ public static void main(String[] args){ \ \ \ \ \ \ \ \ \ \ \ System.out.println("111"); \ \ \ }}
${1006_PE}        import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;/*4 10 3 0 10 0 4 02 0 0 00 0 1 0 */public class Main{ \ \ \ public static Integer[] str2nums(String s){ \ \ \ \ \ \ \ return Arrays.stream(s.split(" ")).map(Integer::parseInt).toArray(Integer[]::new); \ \ \ } \ \ \ public static void main(String[] args) throws IOException { \ \ \ \ \ \ \ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \ \ \ \ \ \ \ int n = Integer.parseInt(br.readLine()); \ \ \ \ \ \ \ List<int[]>[] g = new ArrayList[n]; \ \ \ \ \ \ \ Arrays.setAll(g,e->new ArrayList<>()); \ \ \ \ \ \ \ for (int i = 0; i < n; i++) { \ \ \ \ \ \ \ \ \ \ \ Integer[] nums = str2nums(br.readLine()); \ \ \ \ \ \ \ \ \ \ \ for (int j = 0; j < n; j++) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(nums[j]!=0){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ g[i].add(new int[]{j,nums[j]}); \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ } \ \ \ \ \ \ \ HashSet<Integer> vertices = new HashSet<>(); \ \ \ \ \ \ \ vertices.add(0); \ \ \ \ \ \ \ long cost = 0L; \ \ \ \ \ \ \ while(vertices.size()<n){ \ \ \ \ \ \ \ \ \ \ \ int min = Integer.MAX_VALUE; \ \ \ \ \ \ \ \ \ \ \ int v = -1; \ \ \ \ \ \ \ \ \ \ \ for (Integer vertex : vertices) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for (int[] child : g[vertex]) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(!vertices.contains(child[0])){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(min>child[1]){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ min = child[1]; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v = child[0]; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ if(v==-1){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break; \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ cost+=min; \ \ \ \ \ \ \ \ \ \ \ vertices.add(v); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ System.out.print(cost); \ \ \ }}
${1008_AC}        import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;/*4 10 3 0 10 0 4 02 0 0 00 0 1 0 */public class Main{ \ \ \ public static Integer[] str2nums(String s){ \ \ \ \ \ \ \ return Arrays.stream(s.split(" ")).map(Integer::parseInt).toArray(Integer[]::new); \ \ \ } \ \ \ public static void main(String[] args) throws IOException { \ \ \ \ \ \ \ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \ \ \ \ \ \ \ Integer[] ns = str2nums(br.readLine()); \ \ \ \ \ \ \ int n = ns[0]; \ \ \ \ \ \ \ int s = ns[1]; \ \ \ \ \ \ \ Integer[][] graph = new Integer[n][]; \ \ \ \ \ \ \ for (int i = 0; i < n; i++) { \ \ \ \ \ \ \ \ \ \ \ graph[i] = str2nums(br.readLine()); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ List<Integer[]> res = trivialDijkstra(graph, s); \ \ \ \ \ \ \ Integer[] dis = res.get(0); \ \ \ \ \ \ \ StringBuilder sb = new StringBuilder(); \ \ \ \ \ \ \ for (Integer distance : dis) { \ \ \ \ \ \ \ \ \ \ \ if(distance==null){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sb.append(-1); \ \ \ \ \ \ \ \ \ \ \ }else if(distance==0){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ continue; \ \ \ \ \ \ \ \ \ \ \ }else{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sb.append(distance); \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ sb.append(" "); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ System.out.println(sb); \ \ \ } \ \ \ public static List<Integer[]> trivialDijkstra(Integer[][] graph, int source){ \ \ \ \ \ \ \ int n = graph.length; \ \ \ \ \ \ \ Integer[] dis = new Integer[n]; \ \ \ \ \ \ \ Arrays.fill(dis,null); \ \ \ \ \ \ \ dis[source] = 0; \ \ \ \ \ \ \ Integer[] pre = new Integer[n]; \ \ \ \ \ \ \ Arrays.fill(pre,null); \ \ \ \ \ \ \ pre[source] = -1; \ \ \ \ \ \ \ List<Integer> q = new ArrayList<>(); \ \ \ \ \ \ \ for (int i = 0; i < graph[source].length; i++) { \ \ \ \ \ \ \ \ \ \ \ if(i==source) continue; \ \ \ \ \ \ \ \ \ \ \ Integer w = graph[source][i]; \ \ \ \ \ \ \ \ \ \ \ if(w!=0){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ dis[i] = w; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pre[i] = source; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ q.add(i); \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ } \ \ \ \ \ \ \ while(!q.isEmpty()){ \ \ \ \ \ \ \ \ \ \ \ Integer vertex = q.get(0); \ \ \ \ \ \ \ \ \ \ \ for (Integer i : q) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(dis[i]<dis[vertex]){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ vertex = i; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ q.remove(vertex); \ \ \ \ \ \ \ \ \ \ \ for (int i = 0; i < graph[vertex].length; i++) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Integer w = graph[vertex][i]; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(w!=0){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ int newPath = dis[vertex] + w; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(dis[i]==null||dis[i]>newPath){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ dis[i] = newPath; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(pre[i]==null){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ q.add(i); \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pre[i] = vertex; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ } \ \ \ \ \ \ \ ArrayList<Integer[]> res = new ArrayList<>(); \ \ \ \ \ \ \ res.add(dis); \ \ \ \ \ \ \ res.add(pre); \ \ \ \ \ \ \ return res; \ \ \ }}
${1000_OL}        #include<iostream>\nint main(){while(1){std::cout<<"Hello, World!"<<std::endl;}}
${1000_AC}        import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.StreamTokenizer;import java.util.ArrayDeque;import java.util.Arrays;/*15 5S-###-----##---E#------## */public class Main { \ \ \ static int[][] directions = new int[][]{ \ \ \ \ \ \ \ \ \ \ \ {-1,0}, \ \ \ \ \ \ \ \ \ \ \ {0,1}, \ \ \ \ \ \ \ \ \ \ \ {1,0}, \ \ \ \ \ \ \ \ \ \ \ {0,-1} \ \ \ }; \ \ \ public static void main(String[] args) throws IOException { \ \ \ \ \ \ \ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \ \ \ \ \ \ \ int n = Integer.parseInt(br.readLine()); \ \ \ \ \ \ \ int[][] maze = new int[100][100]; \ \ \ \ \ \ \ for (int i = 0; i < n; i++) { \ \ \ \ \ \ \ \ \ \ \ solve(br,maze); \ \ \ \ \ \ \ } \ \ \ } \ \ \ private static void solve(BufferedReader br,int[][] maze) throws IOException { \ \ \ \ \ \ \ String[] nm = br.readLine().split(" "); \ \ \ \ \ \ \ int n = Integer.parseInt(nm[0]); \ \ \ \ \ \ \ int m = Integer.parseInt(nm[1]); \ \ \ \ \ \ \ for (int i = 0; i < n; i++) { \ \ \ \ \ \ \ \ \ \ \ Arrays.fill(maze[i],Integer.MAX_VALUE); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ int ex=0,ey=0; \ \ \ \ \ \ \ int sx=0,sy=0; \ \ \ \ \ \ \ for (int i = 0; i < n; i++) { \ \ \ \ \ \ \ \ \ \ \ char[] ch = br.readLine().toCharArray(); \ \ \ \ \ \ \ \ \ \ \ for (int j = 0; j < m; j++) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ char c = ch[j]; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(c=='S'){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ maze[i][j] = 0; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sx = i; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sy = j; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }else if(c=='#'){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ maze[i][j] = -1; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }else if(c=='E'){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ex = i; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ey = j; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ArrayDeque<int[]> q = new ArrayDeque<>(); \ \ \ \ \ \ \ q.offerLast(new int[]{sx,sy}); \ \ \ \ \ \ \ int x,y,nx,ny; \ \ \ \ \ \ \ while(!q.isEmpty()){ \ \ \ \ \ \ \ \ \ \ \ int[] cors = q.pollFirst(); \ \ \ \ \ \ \ \ \ \ \ x = cors[0]; \ \ \ \ \ \ \ \ \ \ \ y = cors[1]; \ \ \ \ \ \ \ \ \ \ \ int dis = maze[x][y]; \ \ \ \ \ \ \ \ \ \ \ if(x==ex && y==ey){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ System.out.println(dis); \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return; \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ for (int[] direction : directions) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ nx = x+direction[0]; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ny = y+direction[1]; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(checkValid(nx,ny,n,m) && maze[nx][ny]!=-1 && maze[nx][ny]==Integer.MAX_VALUE){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ maze[nx][ny] = dis+1; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ q.offerLast(new int[]{nx,ny}); \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ } \ \ \ \ \ \ \ System.out.println(-1); \ \ \ } \ \ \ private static boolean checkValid(int x,int y,int n,int m){ \ \ \ \ \ \ \ return x>=0 && x<n && y>=0 && y<m; \ \ \ }}
${1001_AC}        import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;/*4 3 5 8 117 2 6 8 9 11 15 20 */public class Main{ \ \ \ public static Integer[] str2nums(String s){ \ \ \ \ \ \ \ return Arrays.stream(s.split(" ")).map(Integer::parseInt).toArray(Integer[]::new); \ \ \ } \ \ \ public static void main(String[] args) throws IOException { \ \ \ \ \ \ \ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \ \ \ \ \ \ \ String s1,s2; \ \ \ \ \ \ \ while((s1=br.readLine())!=null && (s2=br.readLine())!=null){ \ \ \ \ \ \ \ \ \ \ \ if(s1.isEmpty()||s2.isEmpty()){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break; \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ Integer[] A = str2nums(s1); \ \ \ \ \ \ \ \ \ \ \ Integer[] B = str2nums(s2); \ \ \ \ \ \ \ \ \ \ \ StringBuilder sb = getStringBuilder(A, B); \ \ \ \ \ \ \ \ \ \ \ System.out.println(sb); \ \ \ \ \ \ \ } \ \ \ } \ \ \ private static StringBuilder getStringBuilder(Integer[] A, Integer[] B) { \ \ \ \ \ \ \ int i,j; \ \ \ \ \ \ \ i = j = 1; \ \ \ \ \ \ \ StringBuilder sb = new StringBuilder(); \ \ \ \ \ \ \ while(i< A.length&&j< B.length){ \ \ \ \ \ \ \ \ \ \ \ if(A[i]< B[j]){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sb.append(A[i++]); \ \ \ \ \ \ \ \ \ \ \ }else{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sb.append(B[j++]); \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ sb.append(" "); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ while(i< A.length){ \ \ \ \ \ \ \ \ \ \ \ sb.append(A[i++]); \ \ \ \ \ \ \ \ \ \ \ sb.append(" "); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ while(j< B.length){ \ \ \ \ \ \ \ \ \ \ \ sb.append(B[j++]); \ \ \ \ \ \ \ \ \ \ \ sb.append(" "); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ return sb; \ \ \ }}
${1002_AC}        import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.Comparator;import java.util.Map;import java.util.TreeMap;/*3 2 4 1 7 02 4 1 12 31 43 2 4 1 7 02 4 -4 1 */public class Main{ \ \ \ public static Integer[] str2nums(String s){ \ \ \ \ \ \ \ return Arrays.stream(s.split(" ")).map(Integer::parseInt).toArray(Integer[]::new); \ \ \ } \ \ \ public static void main(String[] args) throws IOException { \ \ \ \ \ \ \ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \ \ \ \ \ \ \ String s1,s2; \ \ \ \ \ \ \ while((s1=br.readLine())!=null && (s2=br.readLine())!=null){ \ \ \ \ \ \ \ \ \ \ \ if(s1.isEmpty()||s2.isEmpty()){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break; \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ Integer[] A = str2nums(s1); \ \ \ \ \ \ \ \ \ \ \ Integer[] B = str2nums(s2); \ \ \ \ \ \ \ \ \ \ \ StringBuilder sb = getStringBuilder(A, B); \ \ \ \ \ \ \ \ \ \ \ System.out.println(sb); \ \ \ \ \ \ \ } \ \ \ } \ \ \ private static StringBuilder getStringBuilder(Integer[] A, Integer[] B) { \ \ \ \ \ \ \ TreeMap<Integer, Integer> map = new TreeMap<>((o1, o2) -> -Integer.compare(o1,o2)); \ \ \ \ \ \ \ addCo(map,A); \ \ \ \ \ \ \ addCo(map,B); \ \ \ \ \ \ \ StringBuilder sb = new StringBuilder(); \ \ \ \ \ \ \ for (Map.Entry<Integer, Integer> entry : map.entrySet()) { \ \ \ \ \ \ \ \ \ \ \ if(entry.getValue()==0){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ continue; \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ sb.append(entry.getValue()).append(" ").append(entry.getKey()).append(" "); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ return sb; \ \ \ } \ \ \ private static void addCo(TreeMap<Integer,Integer> map,Integer[] nums){ \ \ \ \ \ \ \ for (int i = 0; i < nums.length; i+=2) { \ \ \ \ \ \ \ \ \ \ \ Integer co = nums[i]; \ \ \ \ \ \ \ \ \ \ \ Integer pos = nums[i + 1]; \ \ \ \ \ \ \ \ \ \ \ map.merge(pos,co,Integer::sum); \ \ \ \ \ \ \ } \ \ \ }}
${1003_AC}        import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.Comparator;import java.util.Map;import java.util.TreeMap;/*3 2 4 1 7 02 4 1 12 31 43 2 4 1 7 02 4 -4 1 */public class Main{ \ \ \ public static Integer[] str2nums(String s){ \ \ \ \ \ \ \ return Arrays.stream(s.split(" ")).map(Integer::parseInt).toArray(Integer[]::new); \ \ \ } \ \ \ public static void main(String[] args) throws IOException { \ \ \ \ \ \ \ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \ \ \ \ \ \ \ String s1,s2; \ \ \ \ \ \ \ while((s1=br.readLine())!=null && (s2=br.readLine())!=null){ \ \ \ \ \ \ \ \ \ \ \ if(s1.isEmpty()||s2.isEmpty()){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break; \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ Integer[] A = str2nums(s1); \ \ \ \ \ \ \ \ \ \ \ Integer[] B = str2nums(s2); \ \ \ \ \ \ \ \ \ \ \ StringBuilder sb = getStringBuilder(A, B); \ \ \ \ \ \ \ \ \ \ \ System.out.println(sb); \ \ \ \ \ \ \ } \ \ \ } \ \ \ private static StringBuilder getStringBuilder(Integer[] A, Integer[] B) { \ \ \ \ \ \ \ TreeMap<Integer, Integer> map = new TreeMap<>((o1, o2) -> -Integer.compare(o1,o2)); \ \ \ \ \ \ \ addCo(map,A); \ \ \ \ \ \ \ addCo(map,B); \ \ \ \ \ \ \ StringBuilder sb = new StringBuilder(); \ \ \ \ \ \ \ for (Map.Entry<Integer, Integer> entry : map.entrySet()) { \ \ \ \ \ \ \ \ \ \ \ if(entry.getValue()==0){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ continue; \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ sb.append(entry.getValue()).append(" ").append(entry.getKey()).append(" "); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ return sb; \ \ \ } \ \ \ private static void addCo(TreeMap<Integer,Integer> map,Integer[] nums){ \ \ \ \ \ \ \ for (int i = 0; i < nums.length; i+=2) { \ \ \ \ \ \ \ \ \ \ \ Integer co = nums[i]; \ \ \ \ \ \ \ \ \ \ \ Integer pos = nums[i + 1]; \ \ \ \ \ \ \ \ \ \ \ map.merge(pos,co,Integer::sum); \ \ \ \ \ \ \ } \ \ \ }}
${1004_AC}        import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;/*abaabcac */public class Main{ \ \ \ public static Integer[] brReadLine(BufferedReader br) throws IOException { \ \ \ \ \ \ \ return Arrays.stream(br.readLine().split(" ")) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .map(Integer::parseInt).toArray(Integer[]::new); \ \ \ } \ \ \ public static void main(String[] args) throws IOException { \ \ \ \ \ \ \ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \ \ \ \ \ \ \ String str = br.readLine(); \ \ \ \ \ \ \ int[] next = buildNext(str); \ \ \ \ \ \ \ for (int n = 0; n < next.length-1; n++) { \ \ \ \ \ \ \ \ \ \ \ System.out.print(++next[n]+" "); \ \ \ \ \ \ \ } \ \ \ } \ \ \ private static int[] buildNext(String p){ \ \ \ \ \ \ \ char[] ch = p.toCharArray(); \ \ \ \ \ \ \ int plen = ch.length; \ \ \ \ \ \ \ int[] next = new int[plen+1]; \ \ \ \ \ \ \ next[0] = -1; \ \ \ \ \ \ \ int k = next[0]; \ \ \ \ \ \ \ int j = 0; \ \ \ \ \ \ \ while(j<plen){ \ \ \ \ \ \ \ \ \ \ \ if(k==-1||ch[j]==ch[k]) next[++j] = ++k; \ \ \ \ \ \ \ \ \ \ \ else k = next[k]; \ \ \ \ \ \ \ } \ \ \ \ \ \ \ return next; \ \ \ }}
${1005_AC}        import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;/*85 29 7 8 14 23 3 11 */class Node{ \ \ \ int idx; \ \ \ Node left; \ \ \ Node right; \ \ \ long weight; \ \ \ Node(int id,Node l,Node r,long w){ \ \ \ \ \ \ \ idx = id; \ \ \ \ \ \ \ left = l; \ \ \ \ \ \ \ right = r; \ \ \ \ \ \ \ weight = w; \ \ \ }}public class Main{ \ \ \ public static Integer[] str2nums(String s){ \ \ \ \ \ \ \ return Arrays.stream(s.split(" ")).map(Integer::parseInt).toArray(Integer[]::new); \ \ \ } \ \ \ public static void main(String[] args) throws IOException { \ \ \ \ \ \ \ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \ \ \ \ \ \ \ int n = Integer.parseInt(br.readLine()); \ \ \ \ \ \ \ Integer[] weights = str2nums(br.readLine()); \ \ \ \ \ \ \ PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) -> { \ \ \ \ \ \ \ \ \ \ \ if(o1.weight==o2.weight){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return Integer.compare(o1.idx,o2.idx); \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ return Long.compare(o1.weight,o2.weight); \ \ \ \ \ \ \ }); \ \ \ \ \ \ \ for (int i = 0; i < weights.length; i++) { \ \ \ \ \ \ \ \ \ \ \ Node node = new Node(i, null, null, weights[i]); \ \ \ \ \ \ \ \ \ \ \ pq.offer(node); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ if(n==1){ \ \ \ \ \ \ \ \ \ \ \ System.out.println("0"); \ \ \ \ \ \ \ \ \ \ \ return; \ \ \ \ \ \ \ } \ \ \ \ \ \ \ int idx = n; \ \ \ \ \ \ \ while(pq.size()>1){ \ \ \ \ \ \ \ \ \ \ \ Node top1 = pq.poll(); \ \ \ \ \ \ \ \ \ \ \ Node top2 = pq.poll(); \ \ \ \ \ \ \ \ \ \ \ assert top2!=null; \ \ \ \ \ \ \ \ \ \ \ Node l,r; \ \ \ \ \ \ \ \ \ \ \ if(top1.idx<top2.idx){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ l = top1; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ r = top2; \ \ \ \ \ \ \ \ \ \ \ }else{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ l = top2; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ r = top1; \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ Node node = new Node(idx++, l, r, l.weight + r.weight); \ \ \ \ \ \ \ \ \ \ \ pq.offer(node); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ Node root = pq.peek(); \ \ \ \ \ \ \ String[] ans = new String[n]; \ \ \ \ \ \ \ assert root != null; \ \ \ \ \ \ \ dfs(root,"",ans); \ \ \ \ \ \ \ for (String s : ans) { \ \ \ \ \ \ \ \ \ \ \ System.out.println(s); \ \ \ \ \ \ \ } \ \ \ } \ \ \ private static void dfs(Node node,String s,String[] ans){ \ \ \ \ \ \ \ if(node.idx<ans.length){ \ \ \ \ \ \ \ \ \ \ \ ans[node.idx] = s; \ \ \ \ \ \ \ \ \ \ \ return; \ \ \ \ \ \ \ } \ \ \ \ \ \ \ dfs(node.left,s+"0",ans); \ \ \ \ \ \ \ dfs(node.right,s+"1",ans); \ \ \ }}
${1006_AC}        import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;/*4 10 3 0 10 0 4 02 0 0 00 0 1 0 */public class Main{ \ \ \ public static Integer[] str2nums(String s){ \ \ \ \ \ \ \ return Arrays.stream(s.split(" ")).map(Integer::parseInt).toArray(Integer[]::new); \ \ \ } \ \ \ public static void main(String[] args) throws IOException { \ \ \ \ \ \ \ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \ \ \ \ \ \ \ int n = Integer.parseInt(br.readLine()); \ \ \ \ \ \ \ List<int[]>[] g = new ArrayList[n]; \ \ \ \ \ \ \ Arrays.setAll(g,e->new ArrayList<>()); \ \ \ \ \ \ \ for (int i = 0; i < n; i++) { \ \ \ \ \ \ \ \ \ \ \ Integer[] nums = str2nums(br.readLine()); \ \ \ \ \ \ \ \ \ \ \ for (int j = 0; j < n; j++) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(nums[j]!=0){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ g[i].add(new int[]{j,nums[j]}); \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ } \ \ \ \ \ \ \ HashSet<Integer> vertices = new HashSet<>(); \ \ \ \ \ \ \ vertices.add(0); \ \ \ \ \ \ \ long cost = 0L; \ \ \ \ \ \ \ while(vertices.size()<n){ \ \ \ \ \ \ \ \ \ \ \ int min = Integer.MAX_VALUE; \ \ \ \ \ \ \ \ \ \ \ int v = -1; \ \ \ \ \ \ \ \ \ \ \ for (Integer vertex : vertices) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for (int[] child : g[vertex]) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(!vertices.contains(child[0])){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(min>child[1]){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ min = child[1]; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v = child[0]; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ if(v==-1){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break; \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ cost+=min; \ \ \ \ \ \ \ \ \ \ \ vertices.add(v); \ \ \ \ \ \ \ } \ \ \ \ \ \ \ System.out.println(cost); \ \ \ }}
${1007_AC}        import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;/*40 1 0 00 0 1 00 0 0 00 0 1 0 */public class Main{ \ \ \ public static Integer[] str2nums(String s){ \ \ \ \ \ \ \ return Arrays.stream(s.split(" ")).map(Integer::parseInt).toArray(Integer[]::new); \ \ \ } \ \ \ public static void main(String[] args) throws IOException { \ \ \ \ \ \ \ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \ \ \ \ \ \ \ int n = Integer.parseInt(br.readLine()); \ \ \ \ \ \ \ List<Integer>[] g = new ArrayList[n]; \ \ \ \ \ \ \ Arrays.setAll(g,e->new ArrayList<>()); \ \ \ \ \ \ \ int[] degree = new int[n]; \ \ \ \ \ \ \ boolean[] vis = new boolean[n]; \ \ \ \ \ \ \ Arrays.fill(degree,0); \ \ \ \ \ \ \ Arrays.fill(vis,false); \ \ \ \ \ \ \ for (int i = 0; i < n; i++) { \ \ \ \ \ \ \ \ \ \ \ Integer[] nums = str2nums(br.readLine()); \ \ \ \ \ \ \ \ \ \ \ for (int j = 0; j < n; j++) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(nums[j]!=0){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ g[i].add(j); \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ degree[j]++; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ } \ \ \ \ \ \ \ ArrayDeque<Integer> q = new ArrayDeque<>(); \ \ \ \ \ \ \ for (int i = 0; i < degree.length; i++) { \ \ \ \ \ \ \ \ \ \ \ if(degree[i]==0){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ q.offerFirst(i); \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ } \ \ \ \ \ \ \ if(q.isEmpty()){ \ \ \ \ \ \ \ \ \ \ \ System.out.println("ERROR"); \ \ \ \ \ \ \ \ \ \ \ return; \ \ \ \ \ \ \ } \ \ \ \ \ \ \ StringBuilder sb = new StringBuilder(); \ \ \ \ \ \ \ while(!q.isEmpty()){ \ \ \ \ \ \ \ \ \ \ \ Integer poll = q.poll(); \ \ \ \ \ \ \ \ \ \ \ sb.append(poll).append(" "); \ \ \ \ \ \ \ \ \ \ \ vis[poll] = true; \ \ \ \ \ \ \ \ \ \ \ for (Integer child : g[poll]) { \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(vis[child]){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ System.out.println("ERROR"); \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ degree[child]--; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(degree[child]==0){ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ q.offerFirst(child); \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ \ \ \ \ } \ \ \ \ \ \ \ } \ \ \ \ \ \ \ System.out.println(sb); \ \ \ }}
